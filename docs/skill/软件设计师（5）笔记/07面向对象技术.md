# 7 面向对象技术

## 7.1 面向对象基础

### 7.1.1 概念

面向对象 = Object + 分类（Class）+ 继承（Inheritance） + 通过消息的通信

#### 1 对象

通常由对象名、属性和方法组成

#### 2 消息

对象之间的通信

#### 3 类

可以分三种：实体类、接口类和控制类

#### 4 继承

#### 5 多态

不同的对象收到同一消息产生完全不同的结果

#### 6 动态绑定

在编译时进行过程调用和响应调用结合的过程，称为静态绑定，动态绑定是运行时进行的

### 7.1.2 面向对象分析

可以将系统的行为和信息间的关系表示为迭代构造特征

#### 1 认定对象

#### 2 组织对象

#### 3 对象间的相互作用

#### 4 基于对象的操作

### 7.1.3 面向对象设计

面向对象设计（OOD）是将OOA（面向对象分析）所创建的模型转换为设计模型

#### 1 面向对象设计的活动

#### 2 面向对象设计的原则

单一；开放、封闭；里氏替换；依赖倒置；接口分离

### 7.1.4 面向对象程序设计

#### 1 类

#### 2 继承和类层次结构

当执行一个子类的实例生成方法时，首先从该子类沿继承路径上溯至它的基类，再自上向下执行父类的实例生成方法；实例消除顺序方法时相反

#### 3 对象、消息传递和方法

对象之间通过消息传递方式进行通信

#### 4 对象自身引用

this 指针

#### 5 重置

指在子类中重新定义父类中已经定义的方法

#### 6 类属类

一种参数多态机制

#### 7 无实例的类

C++，Java 中的抽象类

### 7.1.5 面向对象测试

可以分 4 层进行

1. 算法层
2. 类层
3. 模板层
4. 系统层

## 7.2 UML

统一建模语言（用图行界面来面向对象建模）

### 7.2.1 事物

- 结构事物
- 行为事物
- 分组事物
- 注释事物

### 7.2.2 关系

依赖、关联、泛化、实现

### 7.2.3 UML 中的图

类图、对象图、用例图、交互图、状态图、活动图、构件图 ……

## 7.3 设计模式

### 7.3.1 设计模式的要素

- 模式名称
- 问题
- 解决方案
- 效果

### 7.3.2 创建型设计模式

抽象了实例化过程

#### 1 Abstract Factory（抽象工厂）

创建一系列相关或互相依赖对象的接口

#### 2 Builder（生成器）

将一个复杂对象的构建与它的表示分离

#### 3 Factory Method（工厂方法）

定义一个用于创建对象的接口，让子类决定实例化哪一个类

#### 4 Prototype（原型）

用原型实例指定创建对象的种类，并通过复制原型创建新的对象

#### 5 Singleton（单例）

一个类仅有一个实例，并提供一个访问它的全局访问点

### 7.3.3 结构型设计模式

涉及如何组合类与对象以获得更大的结构

#### 1 Adapter（适配器）

可以使原本由于接口不兼容而不能在一起工作的那些类可以一起工作

#### 2 Bridge（桥接）

将抽象部分与其实现部分分离，使他们可以独立地变化

#### 3 Composite（组合）

将对象组合成树形结构以表示 `部分-整体` 的层次结构

#### 4 Decorator（装饰）

动态地给一个对象添加一些额外的职责尺寸 

#### 5 Facade（外观）

为子系统中的一组接口提供一个一致的界面

#### 6 FlyWeight（享元）

运用共享技术有效地支持大量细粒度的对象

#### 7 Proxy（代理）

为其他对象提供一种代理以控制这个对象的访问

### 7.3.4 行为设计模式

涉及算法和对象间职责的分配

#### 1 Chain of Responsibility（责任链）

使多个对象都有机会处理请求，从而避免请求的发送者与接收者之间的耦合关系

#### 2 Command（命令）

将一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化

#### 3 Interpreter（解释器）

定义一个语言，定义其文法，并定义一个解释器来表示解释语言中的句子

#### 4 Iterator（迭代器）

提供一种方法顺序访问一个聚合对象中的各个元素

#### 5 Mediator（中介者）

用一个中介对象来封装一系列对象的交互

#### 6 Memento（备忘录）

在对象之外，捕获并保存一个对象的内部状态，在之后用于对象的状态复原

#### 7 Observer（观察者）

定义对象间的一种一对多的依赖关系，当对象发生变化时，所有依赖于它的对象都得到通知并被自动更新

#### 8 State（状态）

允许一个对象在其内部状态改变时改变他的行为

#### 9 Strategy（策略）

定义一系列算法，并把他们封装，使它们可以相互替换

#### 10 Template Method（模板方法）

可以让子类不改变一个算法的结构即可重定义该算法的某些特定步骤

#### 11 Visiter（访问者）

允许在不改变各元素的类的前提下定义作用于这些元素的新操作